<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUIC Video Stream - WebCodecs v3.0 - BIGGER PLAYER</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: #1a1a1a;
            color: white;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .main-content {
            width: 100%;
        }
        .stats-header {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
        }
        h1 {
            text-align: center;
            color: #4CAF50;
            margin: 10px 0;
            font-size: 24px;
        }
        .controls {
            text-align: center;
            margin: 15px 0;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .video-container {
            text-align: center;
            margin: 10px 0;
            background: #000;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        #view {
            max-width: 100%;
            max-height: 600px;
            width: auto;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        .status {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
        }
        .status.connected {
            background: #2d5a2d;
            color: #4CAF50;
        }
        .status.disconnected {
            background: #5a2d2d;
            color: #f44336;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: #333;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        .stat-label {
            font-size: 11px;
            color: #ccc;
        }
        .decoder-info {
            margin-top: 15px;
            padding: 10px;
            background: #333;
            border-radius: 8px;
        }
        .decoder-info h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #4CAF50;
        }
        .decoder-info p {
            margin: 0;
            font-size: 11px;
            line-height: 1.4;
        }
        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        @media (max-width: 480px) {
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <h1>üé• QUIC Video Stream</h1>
            
            <div class="controls">
                <button id="connectBtn">Connect via WebSocket üì°</button>
                <button id="connectWtBtn">Connect via WebTransport üöÄ</button>
                <button id="disconnectBtn" disabled>Disconnect</button>
            </div>

            <div id="status" class="status disconnected">
                ‚ùå Disconnected
            </div>

            <div class="stats-header">
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="framesReceived">0</div>
                        <div class="stat-label">Frames</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="bytesReceived">0</div>
                        <div class="stat-label">Data</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="fps">0</div>
                        <div class="stat-label">FPS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="bitrate">0</div>
                        <div class="stat-label">Bitrate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="resolution">0x0</div>
                        <div class="stat-label">Resolution</div>
                    </div>
                </div>
                
                <div class="decoder-info">
                    <h3>üß† WebCodecs H.264</h3>
                    <p><strong>Hardware Acceleration:</strong> Direct H.264 decoding with GPU support. <strong>Zero Dependencies:</strong> Pure browser-native decoding. <strong>QUIC/WebSocket:</strong> Ultra-low latency transport. <strong>Real-time:</strong> Frame-by-frame processing.</p>
                </div>
            </div>

            <div class="video-container">
                <canvas id="view" width="1920" height="1080"></canvas>
            </div>
        </div>
    </div>

    <!-- Remove MP4Box for now - it's complex and needs proper setup -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script> -->
    
    <script type="module">
        console.log('üé• LOADING WEBCODECS H.264 DECODER v28.0 - BINARY WEBTRANSPORT!');
        
        // Check browser and WebCodecs support
        console.log('üåê Browser info:', {
            userAgent: navigator.userAgent,
            webCodecsSupported: 'VideoDecoder' in window,
            hardwareAcceleration: navigator.hardwareConcurrency || 'unknown'
        });
        
        // Test basic WebCodecs support
        if ('VideoDecoder' in window) {
            try {
                const testSupport = await VideoDecoder.isConfigSupported({
                    codec: 'avc1.42E01E' // Baseline profile
                });
                console.log('üß™ Basic WebCodecs test (Baseline Profile):', testSupport);
            } catch (e) {
                console.error('üß™ Basic WebCodecs test failed:', e);
            }
        } else {
            console.error('‚ùå WebCodecs not supported in this browser!');
        }
        
        const canvas = document.getElementById('view');
        const ctx = canvas.getContext('2d', { desynchronized: true });
        
        // Function to resize canvas to maintain aspect ratio
        function resizeCanvas(videoWidth, videoHeight) {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 4; // Account for border
            const maxHeight = 600; // Fixed max height for consistent player size
            
            // Calculate aspect ratio
            const aspectRatio = videoWidth / videoHeight;
            
            let newWidth = containerWidth;
            let newHeight = containerWidth / aspectRatio;
            
            // If height exceeds max, scale down
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                newWidth = maxHeight * aspectRatio;
            }
            
            // Ensure minimum size
            if (newHeight < 300) {
                newHeight = 300;
                newWidth = 300 * aspectRatio;
            }
            
            // Set canvas display size (CSS)
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
            
            // Set canvas internal resolution to match video
            canvas.width = videoWidth;
            canvas.height = videoHeight;
            
            console.log(`üìê Canvas resized: ${newWidth}x${newHeight} display, ${videoWidth}x${videoHeight} internal`);
        }

        // --- WebCodecs with proper avcC handling ---
        let decoder;
        let gotConfig = false;
        let avccConfig = null;
        let t0 = performance.now();
        let frameCount = 0;
        
        // Frame sequence tracking for packet loss detection
        let expectedFrameNumber = null;
        let totalLostFrames = 0;
        
        // Frame timing analysis
        let lastFrameTime = null;
        let frameIntervals = [];
        let slowFrameCount = 0;
        let fastFrameCount = 0;

        function hex2(n) { return n.toString(16).padStart(2,'0').toUpperCase(); }
        
        // Check for frame sequence gaps (packet loss detection)
        function checkFrameSequence(frameNumber) {
            if (expectedFrameNumber === null) {
                // First frame - initialize tracking
                expectedFrameNumber = frameNumber + 1;
                console.log(`üé¨ Starting frame sequence tracking from #${frameNumber}`);
                return;
            }
            
            if (frameNumber !== expectedFrameNumber) {
                if (frameNumber > expectedFrameNumber) {
                    // Frames were lost
                    const lostCount = frameNumber - expectedFrameNumber;
                    totalLostFrames += lostCount;
                    console.warn(`‚ö†Ô∏è FRAME LOSS DETECTED: Expected #${expectedFrameNumber}, got #${frameNumber} (${lostCount} frames lost, ${totalLostFrames} total lost)`);
                } else if (frameNumber < expectedFrameNumber) {
                    // Out of order or duplicate frame
                    console.warn(`‚ö†Ô∏è OUT-OF-ORDER FRAME: Expected #${expectedFrameNumber}, got #${frameNumber} (duplicate or reordered)`);
                    return; // Don't update expected number for out-of-order frames
                }
            }
            
            expectedFrameNumber = frameNumber + 1;
        }
        
        // Analyze frame timing to detect speed variations
        function analyzeFrameTiming(frameNumber) {
            const now = performance.now();
            
            if (lastFrameTime !== null) {
                const interval = now - lastFrameTime;
                frameIntervals.push(interval);
                
                // Keep only last 30 intervals for rolling analysis
                if (frameIntervals.length > 30) {
                    frameIntervals.shift();
                }
                
                // Calculate expected interval (15fps = 66.67ms, 30fps = 33.33ms)
                const expectedInterval = 66.67; // Assuming 15fps from Mac app
                const tolerance = expectedInterval * 0.5; // 50% tolerance
                
                if (interval > expectedInterval + tolerance) {
                    slowFrameCount++;
                    console.warn(`üêå SLOW FRAME #${frameNumber}: ${interval.toFixed(1)}ms (expected ~${expectedInterval.toFixed(1)}ms) - ${slowFrameCount} slow frames total`);
                } else if (interval < expectedInterval - tolerance) {
                    fastFrameCount++;
                    console.warn(`‚ö° FAST FRAME #${frameNumber}: ${interval.toFixed(1)}ms (expected ~${expectedInterval.toFixed(1)}ms) - ${fastFrameCount} fast frames total`);
                }
                
                // Log timing stats every 100 frames
                if (frameNumber % 100 === 0 && frameIntervals.length >= 10) {
                    const avgInterval = frameIntervals.reduce((a, b) => a + b, 0) / frameIntervals.length;
                    const minInterval = Math.min(...frameIntervals);
                    const maxInterval = Math.max(...frameIntervals);
                    const jitter = maxInterval - minInterval;
                    
                    console.log(`üìä FRAME TIMING STATS (last ${frameIntervals.length} frames):`);
                    console.log(`   Average: ${avgInterval.toFixed(1)}ms (${(1000/avgInterval).toFixed(1)} fps)`);
                    console.log(`   Range: ${minInterval.toFixed(1)}ms - ${maxInterval.toFixed(1)}ms`);
                    console.log(`   Jitter: ${jitter.toFixed(1)}ms`);
                    console.log(`   Slow frames: ${slowFrameCount}, Fast frames: ${fastFrameCount}`);
                }
            }
            
            lastFrameTime = now;
        }

        // Parse AVCC Access Unit and detect IDR frames
        function parseAvccAU(avccBytes) {
            const dv = new DataView(avccBytes.buffer, avccBytes.byteOffset, avccBytes.byteLength);
            let off = 0, isIDR = false;
            const nals = [];

            while (off + 4 <= avccBytes.length) {
                const len = dv.getUint32(off, false); // big-endian
                off += 4;
                if (len === 0 || off + len > avccBytes.length) throw new Error('Bad AVCC lengths');
                const type = avccBytes[off] & 0x1F;
                nals.push({ type, len });
                if (type === 5) isIDR = true; // IDR
                off += len;
            }
            if (off !== avccBytes.length) throw new Error('Trailing bytes in AU');
            return { nals, isIDR };
        }

        async function configureDecoderWithAvcc(avccData) {
            console.log('üîß Configuring decoder with avcC:', avccData.length, 'bytes');
            console.log('üîß avcC preview:', Array.from(avccData.slice(0, 16)).map(b => hex2(b)).join(' '));
            
            // Extract codec string from avcC
            const profile_idc = avccData[1];
            const compat = avccData[2];
            const level_idc = avccData[3];
            const lengthSizeMinusOne = avccData[4] & 0x03;
            const codec = `avc1.${hex2(profile_idc)}${hex2(compat)}${hex2(level_idc)}`;
            
            console.log('üîß Codec string from avcC:', codec);
            console.log('üîß avcC lengthSize:', lengthSizeMinusOne + 1);
            
            if (lengthSizeMinusOne !== 3) {
                console.warn('‚ö†Ô∏è Unexpected lengthSize:', lengthSizeMinusOne + 1, '(expected 4)');
            }
            
            // Force software decoding for stability (hardware decoder crashes after ~7 frames)
            let config = { codec, description: avccData, hardwareAcceleration: 'prefer-software' };
            let testSupport;
            
            try {
                testSupport = await VideoDecoder.isConfigSupported(config);
                
                if (!testSupport.supported) {
                    console.error('‚ùå Software codec not supported:', codec);
                    return false;
                } else {
                    console.log('‚úÖ Codec supported:', codec, 'with SOFTWARE decoding');
                }
            } catch (e) {
                console.error('‚ùå Codec support test failed:', e);
                return false;
            }

            // Create decoder
            decoder = new VideoDecoder({
                output: (frame) => {
                    // Process frames immediately without requestAnimationFrame batching to reduce stuttering
                    try {
                        // Resize canvas if video dimensions changed
                        if (canvas.width !== frame.codedWidth || canvas.height !== frame.codedHeight) {
                            canvas.width = frame.codedWidth;
                            canvas.height = frame.codedHeight;
                            console.log(`üìê Canvas resized: ${canvas.width}x${canvas.height}`);
                        }
                        
                        // Update resolution stat
                        document.getElementById('resolution').textContent = `${frame.codedWidth}x${frame.codedHeight}`;
                        
                        // Draw frame at full resolution immediately
                        ctx.drawImage(frame, 0, 0, frame.codedWidth, frame.codedHeight);
                        console.log('üé¨ Frame rendered:', frame.codedWidth + 'x' + frame.codedHeight);
                    } finally {
                        frame.close();
                    }
                },
                error: (e) => {
                    console.error('‚ùå Decoder error:', e.name, e.message);
                    console.error('‚ùå Decoder state:', decoder?.state);
                    
                    // Close the failed decoder
                    try { decoder.close(); } catch {}
                    decoder = null;
                    gotConfig = false;
                    waitingForKeyframe = true;
                    
                    console.log('üîÑ Decoder reset - waiting for next keyframe to recover...');
                }
            });

            // Configure decoder
            try {
                decoder.configure(config);
                gotConfig = true;
                avccConfig = avccData;
                console.log('‚úÖ Decoder configured with server avcC:', codec, 'using', config.hardwareAcceleration);
                return true;
            } catch (e) {
                console.error('‚ùå Decoder configuration failed:', e);
                decoder = null;
                gotConfig = false;
                return false;
            }
        }

        // Store H.264 data for download fallback
        let h264Buffer = [];
        let downloadReady = false;
        
        // Process video frames in AVCC format
        async function processVideoFrame(message) {
            // Decode base64 H.264 data
            const avccData = new Uint8Array(atob(message.data).split('').map(c => c.charCodeAt(0)));
            
            // Parse AVCC AU and detect IDR from bitstream (ignore server frame_type)
            let parsed;
            try {
                parsed = parseAvccAU(avccData);
                const nalDetails = parsed.nals.map(n => `${n.type}(${n.len}b)`).join(',');
                console.log(`üîç AVCC AU #${message.frame_number}: ${parsed.nals.length} NALs ‚Üí ${nalDetails}`);
                
                // Detailed NAL analysis for first few frames
                if (message.frame_number <= 550 && message.frame_number >= 540) {
                    parsed.nals.forEach((nal, i) => {
                        const nalTypeNames = {
                            1: 'P-frame', 2: 'Partition-A', 3: 'Partition-B', 4: 'Partition-C',
                            5: 'IDR', 6: 'SEI', 7: 'SPS', 8: 'PPS', 9: 'AUD', 12: 'Filler'
                        };
                        const typeName = nalTypeNames[nal.type] || 'Unknown';
                        console.log(`  üìã NAL ${i}: Type ${nal.type} (${typeName}), ${nal.len} bytes`);
                    });
                }
            } catch (e) {
                console.error('‚ùå AVCC validation failed:', e.message);
                return;
            }

            const isKeyframe = parsed.isIDR; // Derive from bitstream, not server flag
            console.log(`üì¶ Processing H.264 frame #${message.frame_number}: ${avccData.length} bytes (${isKeyframe ? 'KEYFRAME' : 'DELTA'})`);
            
            // Check for frame sequence gaps (packet loss detection)
            checkFrameSequence(message.frame_number);
            
            // Update stats
            stats.framesReceived++;
            stats.bytesReceived += avccData.length;
            if (isKeyframe) stats.keyframes++;
            
            // Update display
            updateStats();
            
            // Try WebCodecs decoding
            await processAvccFrame(avccData, isKeyframe);
        }

        // Process binary video frames (for WebTransport)
        async function processVideoFrameBinary(message) {
            // message.data_binary is already Uint8Array - no base64 decoding needed!
            const avccData = message.data_binary;
            
            // Parse AVCC AU and detect IDR from bitstream (ignore server frame_type)
            let parsed;
            try {
                parsed = parseAvccAU(avccData);
                const nalDetails = parsed.nals.map(n => `${n.type}(${n.len}b)`).join(',');
                console.log(`üîç BINARY AU #${message.frame_number}: ${parsed.nals.length} NALs ‚Üí ${nalDetails}`);
            } catch (e) {
                console.error('‚ùå BINARY AVCC validation failed:', e.message);
                return;
            }

            const isKeyframe = parsed.isIDR; // Derive from bitstream, not server flag
            console.log(`üì¶ Processing BINARY H.264 frame #${message.frame_number}: ${avccData.length} bytes (${isKeyframe ? 'KEYFRAME' : 'DELTA'})`);
            
            // Check for frame sequence gaps (packet loss detection)
            checkFrameSequence(message.frame_number);
            
            // Analyze frame timing to detect speed variations
            analyzeFrameTiming(message.frame_number);
            
            // Update stats
            stats.framesReceived++;
            stats.bytesReceived += avccData.length;
            updateStats();
            
            // Try WebCodecs decoding (same as regular frames)
            await processAvccFrame(avccData, isKeyframe);
        }

        // Process AVCC frames (length-prefixed NAL units)
        let waitingForKeyframe = true;
        
        async function processAvccFrame(avccData, isKeyframe) {
            if (!gotConfig || !decoder || decoder.state !== 'configured') {
                console.log('‚è≥ Decoder not ready, skipping frame...');
                return;
            }
            
            // Wait for keyframe after decoder configuration
            if (waitingForKeyframe && !isKeyframe) {
                console.log('‚è≥ Waiting for keyframe to start decoding...');
                return;
            }
            
            if (waitingForKeyframe && isKeyframe) {
                waitingForKeyframe = false;
                console.log('üéâ First keyframe received - starting decoding!');
                
                // If decoder was reset due to error, reconfigure it
                if (!gotConfig && avccConfig) {
                    console.log('üîÑ Reconfiguring decoder after error recovery...');
                    await configureDecoderWithAvcc(avccConfig);
                    if (!gotConfig) {
                        console.error('‚ùå Failed to reconfigure decoder');
                        return;
                    }
                }
            }
            
            // Use dynamic timestamps based on actual frame arrival time
            const timestampUs = Math.round((performance.now() - t0) * 1000);
            frameCount++;
            
            try {
                const chunk = new EncodedVideoChunk({
                    type: isKeyframe ? 'key' : 'delta',
                    timestamp: timestampUs, // Sequential timestamps
                    data: avccData
                });
                
                decoder.decode(chunk);
                console.log(`üé¨ Decoded ${isKeyframe ? 'KEYFRAME' : 'delta'} #${frameCount}: ${avccData.length} bytes (ts: ${timestampUs}Œºs)`);
                
                // Debug: Log failing frame data for analysis
                if (frameCount <= 5) {
                    const preview = Array.from(avccData.slice(0, 32)).map(b => hex2(b)).join(' ');
                    console.log(`üîç Frame #${frameCount} AVCC preview: ${preview}`);
                }
            } catch (e) {
                console.error('‚ùå Decode failed:', e);
                
                // Log failing frame for analysis
                if (frameCount <= 5) {
                    const preview = Array.from(avccData.slice(0, 64)).map(b => hex2(b)).join(' ');
                    console.error(`üí• FAILING Frame #${frameCount} (${avccData.length}b): ${preview}`);
                }
            }
        }

        // Old decoder configuration removed - now using server-provided avcC
        
        let websocket = null;
        let stats = {
            framesReceived: 0,
            bytesReceived: 0,
            startTime: null,
            lastFrameTime: null
        };

        // Setup button event listeners
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectBtn').addEventListener('click', connectWebSocket);
            document.getElementById('connectWtBtn').addEventListener('click', connectWebTransport);
            document.getElementById('disconnectBtn').addEventListener('click', disconnect);
        });
        
        // Initial canvas sizing - set a good default size
        resizeCanvas(1920, 1080); // Default to common screen capture resolution

        function updateStatus(message, className) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${className}`;
        }

        function disconnect() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            if (webtransport) {
                webtransport.close();
                webtransport = null;
            }
            if (decoder) {
                decoder.close();
                decoder = null;
            }
            gotConfig = false;
            avccConfig = null;
            frameCount = 0;
            waitingForKeyframe = true;
            
            // Reset frame sequence tracking
            expectedFrameNumber = null;
            totalLostFrames = 0;
            lastFrameTime = null;
            frameIntervals = [];
            slowFrameCount = 0;
            fastFrameCount = 0;
            
            updateStatus('‚ùå Disconnected', 'disconnected');
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('connectWtBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
        }




        async function processH264Frame(message) {
            stats.framesReceived++;
            
            // Decode base64 H.264 data
            const h264Data = atob(message.data);
            const bytes = new Uint8Array(h264Data.length);
            for (let i = 0; i < h264Data.length; i++) {
                bytes[i] = h264Data.charCodeAt(i);
            }
            
            stats.bytesReceived += bytes.byteLength;
            console.log(`üì¶ Processing H.264 frame #${message.frame_number}: ${bytes.length} bytes`);
            
            // Check for frame sequence gaps (packet loss detection)
            checkFrameSequence(message.frame_number);

            // Split into NAL units (without start codes)
            const nals = [...iterateNalUnitsAnnexB(bytes)];
            if (nals.length === 0) return;

            // Debug: Show first few bytes of H.264 data
            if (message.frame_number % 30 === 0) {
                const preview = Array.from(bytes.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                console.log(`üîç H.264 data preview: ${preview}`);
            }

            // Track SPS/PPS whenever we see them (log only first time)
            for (const n of nals) {
                const t = nalType(n);
                if (t === 7) {
                    if (!spsLatest) {
                        console.log(`üìã Found SPS NAL unit (${n.length} bytes): ${Array.from(n.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    }
                    spsLatest = n; // Always update SPS
                }
                if (t === 8) {
                    if (!ppsLatest) {
                        console.log(`üìã Found PPS NAL unit (${n.length} bytes): ${Array.from(n.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    }
                    ppsLatest = n; // Always update PPS
                }
            }

            // Decide if this chunk is a key frame (has an IDR NAL)
            const key = nals.some(isIDR);
            console.log(`üé¨ Frame type: ${key ? 'KEYFRAME' : 'DELTA'} (${nals.length} NAL units)`);

            // Wait for keyframe before starting decoding
            if (waitingForKeyframe && !key) {
                console.log('‚è≥ Waiting for keyframe to start decoding...');
                return;
            }

            // Configure decoder when we have SPS+PPS and not already configured
            if (!gotConfig && spsLatest && ppsLatest) {
                await ensureDecoderConfigured();
                if (!gotConfig) {
                    console.log('‚è≥ Failed to configure decoder...');
                    return;
                }
            }

            // If this is our first keyframe, we can start decoding
            if (waitingForKeyframe && key) {
                waitingForKeyframe = false;
                console.log('üéâ First keyframe received - starting decoding!');
            }

            // Make sure decoder is ready
            if (!gotConfig || !decoder) {
                console.log('‚è≥ Decoder not ready, skipping frame...');
                return;
            }
            
            // Debug: Show decoder state
            if (decoder.state !== "configured") {
                console.log(`üîß Decoder state: ${decoder.state} (expected: configured)`);
            }

            // WebCodecs accepts H.264 with Annex-B framing when configured with avcC description.
            // Provide monotonically increasing timestamps in microseconds.
            const timestampUs = Math.round((performance.now() - t0) * 1000);

            try {
                // Debug: Show what we're sending to decoder for keyframes
                if (key) {
                    console.log(`üîß Keyframe data (${bytes.length}b): ${Array.from(bytes.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    console.log(`üîß NAL units in keyframe: ${nals.map(n => `type=${nalType(n)}(${n.length}b)`).join(', ')}`);
                }
                
                // Debug: Show NAL types for delta frames too
                if (!key && message.frame_number % 10 === 0) {
                    console.log(`üîß Delta frame NAL units: ${nals.map(n => `type=${nalType(n)}(${n.length}b)`).join(', ')}`);
                }

                // For WebCodecs with avcC description, we might need to send only the video data (IDR/P-frames)
                // without the SPS/PPS since they're already in the decoder configuration
                let frameData = bytes;
                
                // For Annex B format WITHOUT description:
                // - Keyframes: send complete frame (SPS + PPS + IDR) 
                // - Delta frames: send only P-frame data (no SPS/PPS repetition)
                // Keep original Annex B format with start codes
                
                if (key) {
                    // Keyframe: send all NAL units (SPS + PPS + IDR)
                    console.log(`üîß Keyframe: keeping complete Annex B format (${bytes.length} bytes)`);
                    frameData = bytes;
                    
                    for (const nal of nals) {
                        const nalType = nal[0] & 0x1F;
                        console.log(`üîß NAL type ${nalType} (${nalType === 7 ? 'SPS' : nalType === 8 ? 'PPS' : nalType === 5 ? 'IDR' : 'Other'}): ${nal.length} bytes`);
                    }
                } else {
                    // Delta frame: send only P-frame data (skip SPS/PPS)
                    const pFrameNals = nals.filter(nal => {
                        const nalType = nal[0] & 0x1F;
                        return nalType === 1; // Only P-frames
                    });
                    
                    if (pFrameNals.length === 0) {
                        console.log(`‚ö†Ô∏è No P-frame NAL units found in delta frame`);
                        return;
                    }
                    
                    // Reconstruct Annex B format with only P-frames
                    const parts = [];
                    let totalSize = 0;
                    
                    for (const nal of pFrameNals) {
                        const startCode = new Uint8Array([0x00, 0x00, 0x00, 0x01]);
                        parts.push(startCode, nal);
                        totalSize += 4 + nal.length;
                        console.log(`üîß NAL type 1 (P-frame): ${nal.length} bytes`);
                    }
                    
                    frameData = new Uint8Array(totalSize);
                    let offset = 0;
                    for (const part of parts) {
                        frameData.set(part, offset);
                        offset += part.length;
                    }
                    
                    console.log(`üîß Delta frame: reconstructed Annex B with ${pFrameNals.length} P-frame(s) (${frameData.length} bytes)`);
                }

                // Debug: Show first few bytes of Annex B data
                const annexBPreview = Array.from(frameData.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                console.log(`üîß Annex B data preview: ${annexBPreview}`);
                
                const chunk = new EncodedVideoChunk({
                    type: key ? 'key' : 'delta',
                    timestamp: timestampUs,
                    data: frameData,
                });
                
                console.log(`üîß Chunk created: type=${chunk.type}, timestamp=${chunk.timestamp}, byteLength=${chunk.byteLength}`);
                console.log(`üîß Decoder state before decode: ${decoder.state}`);
                
                decoder.decode(chunk);
                console.log(`‚úÖ Queued ${key ? 'keyframe' : 'delta'} for decoding (${frameData.length} bytes, Annex B format)`);
                console.log(`üîß Decoder queue length: ${decoder.decodeQueueSize}`);
                
                // For delta frames, add a small delay to let keyframe decode first
                if (!key) {
                    console.log(`‚è≥ Delta frame queued, waiting for keyframe to decode...`);
                }
            } catch (e) {
                console.warn('‚ùå Decode drop:', e);
                // Don't reset decoder on individual frame errors - keep trying
            }
            
            // Update stats
            updateStats();
        }


        function updateStats() {
            document.getElementById('framesReceived').textContent = stats.framesReceived;
            document.getElementById('bytesReceived').textContent = (stats.bytesReceived / 1024 / 1024).toFixed(2) + ' MB';
            
            if (stats.startTime) {
                const elapsed = (Date.now() - stats.startTime) / 1000;
                const fps = stats.framesReceived / elapsed;
                const bitrate = (stats.bytesReceived * 8) / elapsed / 1000; // kbps
                
                document.getElementById('fps').textContent = fps.toFixed(1) + ' fps';
                document.getElementById('bitrate').textContent = bitrate.toFixed(0) + ' kbps';
            }
        }



        async function connectWebTransport() {
            try {
                updateStatus('üöÄ Connecting via WebTransport...', 'connecting');
                
                // Create WebTransport connection
                webtransport = new WebTransport('https://51-21-152-112.nip.io:4433/');
                
                webtransport.ready.then(() => {
                    updateStatus('‚úÖ Connected to WebTransport server', 'connected');
                    stats.startTime = Date.now();
                    
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('connectWtBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                    
                    // Handle incoming unidirectional streams
                    handleWebTransportStreams(webtransport);
                });
                
                webtransport.closed.then(() => {
                    updateStatus('‚ùå WebTransport disconnected', 'disconnected');
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('connectWtBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                });
                
            } catch (error) {
                console.error('WebTransport connection failed:', error);
                updateStatus(`‚ùå WebTransport failed: ${error.message}`, 'disconnected');
            }
        }
        
        async function handleWebTransportStreams(webtransport) {
            const reader = webtransport.incomingUnidirectionalStreams.getReader();
            
            try {
                while (true) {
                    const { value: stream, done } = await reader.read();
                    if (done) break;
                    
                    // Handle each incoming stream (BINARY format)
                    handleWebTransportBinaryStream(stream);
                }
            } catch (error) {
                console.error('WebTransport stream error:', error);
            }
        }
        
        let streamBuffer = new Uint8Array(0);
        
        async function readExactBytes(reader, numBytes) {
            while (streamBuffer.length < numBytes) {
                const { value, done } = await reader.read();
                if (done) throw new Error('Stream ended unexpectedly');
                
                const newBuffer = new Uint8Array(streamBuffer.length + value.length);
                newBuffer.set(streamBuffer);
                newBuffer.set(value, streamBuffer.length);
                streamBuffer = newBuffer;
            }
            
            const result = streamBuffer.slice(0, numBytes);
            streamBuffer = streamBuffer.slice(numBytes);
            return result;
        }
        
        async function handleWebTransportBinaryStream(stream) {
            const reader = stream.getReader();
            
            try {
                while (true) {
                    // Read binary frame header: [frame_type:1][frame_number:4][timestamp:8][data_size:4]
                    const headerBytes = await readExactBytes(reader, 17); // 1+4+8+4 = 17 bytes
                    const headerView = new DataView(headerBytes.buffer);
                    
                    const frameType = headerView.getUint8(0);
                    const frameNumber = headerView.getUint32(1, true); // little-endian
                    const timestamp = headerView.getBigUint64(5, true); // little-endian
                    const dataSize = headerView.getUint32(13, true); // little-endian
                    
                    // Read the binary data
                    const frameData = await readExactBytes(reader, dataSize);
                    
                    // Handle avcC configuration frames
                    if (frameType === 255) { // 0xFF = avcC config
                        console.log('üöÄ Received avcC configuration from WebTransport server (BINARY)');
                        await configureDecoderWithAvcc(frameData);
                    } else {
                        // Handle regular video frames - create message object for compatibility
                        const message = {
                            type: 'video_frame',
                            frame_number: frameNumber,
                            timestamp: Number(timestamp),
                            frame_type: frameType,
                            data_binary: frameData // Raw binary data, no base64!
                        };
                        
                        await processVideoFrameBinary(message);
                    }
                }
            } catch (error) {
                console.error('WebTransport binary stream error:', error);
            }
        }

        let webtransport = null;
        
        async function connectWebSocket() {
            try {
                updateStatus('üîå Connecting to WebSocket server...', 'disconnected');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('connectWtBtn').disabled = true;
                
                // Use secure WebSocket for HTTPS pages, regular WebSocket for HTTP
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                // For HTTPS, try WebSocket on same domain/port, for HTTP use port 8080
                const wsUrl = window.location.protocol === 'https:' 
                    ? `wss://51-21-152-112.nip.io/ws`  // Try same port as HTTPS
                    : `ws://51-21-152-112.nip.io:8080/ws`;
                
                // Create WebSocket connection
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = async () => {
                    updateStatus('‚úÖ Connected to WebSocket server', 'connected');
                    stats.startTime = Date.now();
                    document.getElementById('disconnectBtn').disabled = false;
                };
                
                websocket.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('üì® WebSocket message received:', message.type, message);
                        
                        if (message.type === 'avcc_config') {
                            console.log('üöÄ Received avcC configuration from WebSocket server');
                            const configData = new Uint8Array(atob(message.data).split('').map(c => c.charCodeAt(0)));
                            await configureDecoderWithAvcc(configData);
                        } else if (message.type === 'video_frame') {
                            // Handle avcC configuration frames
                            if (message.frame_type === 255) { // 0xFF = avcC config
                                console.log('üöÄ Received avcC configuration from WebSocket server (in video_frame)');
                                const configData = new Uint8Array(atob(message.data).split('').map(c => c.charCodeAt(0)));
                                await configureDecoderWithAvcc(configData);
                            } else {
                                // Handle regular video frames
                                await processVideoFrame(message);
                            }
                        } else {
                            console.log('ü§∑ Unknown WebSocket message type:', message.type);
                        }
                    } catch (error) {
                        console.error('WebSocket message processing error:', error);
                    }
                };
                
                websocket.onclose = () => {
                    updateStatus('‚ùå WebSocket disconnected', 'disconnected');
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('connectWtBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                    websocket = null;
                };
                
                websocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('‚ùå WebSocket connection failed', 'disconnected');
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('connectWtBtn').disabled = false;
                };
                
            } catch (error) {
                console.error('WebSocket connection failed:', error);
                updateStatus(`‚ùå WebSocket failed: ${error.message}`, 'disconnected');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('connectWtBtn').disabled = false;
            }
        }
        
        // Check WebSocket support (should be available in all modern browsers)
        if (!('WebSocket' in window)) {
            updateStatus('‚ùå WebSocket not supported in this browser', 'disconnected');
            document.getElementById('connectBtn').disabled = true;
        }
        
        // Check WebTransport support
        if (!('WebTransport' in window)) {
            console.warn('‚ö†Ô∏è WebTransport not supported in this browser');
            document.getElementById('connectWtBtn').disabled = true;
        }
    </script>
</body>
</html>